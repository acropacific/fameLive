<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0"
    xmlns:codegen="urn:weborb-cogegen-xslt-lib:xslt"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

  <xsl:import href="codegen.xslt"/>
  
	<xsl:variable name="up" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
	<xsl:variable name="lo" select="'abcdefghijklmnopqrstuvwxyz'"/>

    <xsl:key name="args" match="arg" use="@type"/>

  <xsl:template name="libs.folder.additional.content">
    <file name="readme.txt">
Project structure generated by WebORB includes all the source code and project files except the
library file for the Cairngorm framework. You need to download and place the Cairngorm.swc version 2.2.1 file
(or newer) in this folder.
    </file>
  </xsl:template>

    <!--<xsl:template name="codegen.project.custom">
    <folder name="libs">
	  <file name="readme.txt">
	  Project structure generated by WebORB includes all the source code and project files except the 
	  library file for the Cairngorm framework. You need to download and place the Cairngorm.swc version 2.2.1 file 
	  (or newer) in this folder.
	  </file>
	</folder>
  </xsl:template>-->
  
  <xsl:template name="codegen.service">
  	  <xsl:if test="count(//datatype) != 0">
        <file name="DataTypeInitializer.as">
          <xsl:call-template name="codegen.datatypelist">
            <xsl:with-param name="namespaceName" select="@namespace" />
          </xsl:call-template>  
        </file>
      </xsl:if> 
      
      <folder name="business">
        <file name="{@name}Delegate.as">
          <xsl:call-template name="codegen.description">
            <xsl:with-param name="file-name" select="concat(@name,'Delegate.as')" />
          </xsl:call-template>
          <xsl:call-template name="delegate" />
        </file>
		 <file name="{@name}Services.mxml">
		 <xsl:call-template name="codegen.description">
            <xsl:with-param name="file-name" select="concat(@name,'Services.mxml')" />
          </xsl:call-template>
          <xsl:call-template name="services" />
        </file>
      </folder>
      <folder name="command">
        <xsl:for-each select='method'>
		<xsl:variable name="firstLetter" select="substring(@name, 1,1)"/>
		<xsl:variable name="className" select = "concat(translate($firstLetter, $lo, $up), substring(@name, 2, 30))"/>			
          <file name="{$className}Command.as">
            <xsl:call-template name="codegen.description">
              <xsl:with-param name="file-name" select="concat($className,'Command.as')" />
            </xsl:call-template>
            <xsl:call-template name="command" />
          </file>
        </xsl:for-each>
      </folder>
	  <folder name="event">
        <xsl:for-each select='method'>
		<xsl:variable name="firstLetter" select="substring(@name, 1,1)"/>
		<xsl:variable name="className" select = "concat(translate($firstLetter, $lo, $up), substring(@name, 2, 30))"/>	
          <file name="{$className}Event.as">
            <xsl:call-template name="codegen.description">
              <xsl:with-param name="file-name" select="concat($className,'Event.as')" />
            </xsl:call-template>
            <xsl:call-template name="event" />
          </file>
		  </xsl:for-each>
      </folder>
	  <folder name="control">
          <file name="{@name}Controller.as">
            <xsl:call-template name="codegen.description">
              <xsl:with-param name="file-name" select="concat(@name,'Controller.as')" />
            </xsl:call-template>
            <xsl:call-template name="controller" />
          </file>
      </folder>
    <xsl:if test="//service/datatype">
      <folder name="vo">
        <xsl:for-each select="datatype">
          <file name="{@name}.as">
            <xsl:call-template name="codegen.description">
              <xsl:with-param name="file-name" select="concat(@name,'.as')" />
            </xsl:call-template>
            <xsl:call-template name="vo" />
          </file>
        </xsl:for-each>
      </folder>
    </xsl:if>
  </xsl:template>
  
  
<xsl:template name="services">
   
<cairngorm:ServiceLocator
	xmlns:mx="http://www.adobe.com/2006/mxml" 
	xmlns:cairngorm="http://www.adobe.com/2006/cairngorm">

    <mx:RemoteObject id="{@name}" destination="GenericDestination" source="{@fullname}"
							showBusyCursor="true">
    </mx:RemoteObject>

</cairngorm:ServiceLocator>
 </xsl:template>

  <xsl:template name="vo">
	package <xsl:value-of select="//service/@namespace"/>.vo
    {
    import com.adobe.cairngorm.vo.IValueObject;
      
    [RemoteClass(alias="<xsl:value-of select='@fullname'/>")]
	public class <xsl:value-of select="@name"/> implements IValueObject
		{
        <xsl:for-each select="field">
		[Bindable]
         public var <xsl:value-of select="@name"/>:<xsl:value-of select="@type"/>;
        </xsl:for-each>
		}
    }
  </xsl:template>
  
  <xsl:template name="delegate">
    package <xsl:value-of select="@namespace" />.business
    {
		import mx.rpc.IResponder;
		import com.adobe.cairngorm.business.ServiceLocator;
		import mx.rpc.events.ResultEvent;
		import mx.rpc.AbstractOperation;
	  
    <xsl:if test="//service/datatype">
		import <xsl:value-of select="@namespace" />.vo.*;
    </xsl:if>
		public class <xsl:value-of select="@name"/>Delegate
		{
			private var responder : IResponder;
			private var service : Object;

			public function <xsl:value-of select="@name"/>Delegate(responder : IResponder )
			{
				this.service = ServiceLocator.getInstance().getRemoteObject( "<xsl:value-of select='@name'/>" );
				this.responder = responder;
			}
        
        <xsl:for-each select='method'>
        public function <xsl:value-of select='@name' />(<xsl:for-each select="arg">
          <xsl:if test="position() != 1">, </xsl:if>
          <xsl:value-of select="@name"/>:<xsl:value-of select="@type" />
        </xsl:for-each>) : void
         {

			var call : Object = service.<xsl:value-of select="@name"/>(<xsl:for-each select="arg">
          <xsl:if test="position() != 1">,</xsl:if>
          <xsl:value-of select="@name"/>
        </xsl:for-each>);
        
			call.addResponder( responder );	
        }
        </xsl:for-each>
      }
    }    
  </xsl:template>

  
  <xsl:template name="command">

	package <xsl:value-of select="../@namespace" />.command
	{
		import mx.rpc.IResponder;
		import com.adobe.cairngorm.commands.ICommand;
		import com.adobe.cairngorm.control.CairngormEvent;
		import mx.rpc.events.ResultEvent;
		import mx.rpc.events.FaultEvent;
		import mx.controls.Alert;
		import <xsl:value-of select="../@namespace" />.business.*;
		import <xsl:value-of select="../@namespace" />.event.*;
		<xsl:if test="//service/datatype">
		import <xsl:value-of select="../@namespace" />.vo.*;
		</xsl:if>
   
		<xsl:variable name="firstLetter" select="substring(@name, 1,1)"/>
		<xsl:variable name="className" select = "concat(translate($firstLetter, $lo, $up), substring(@name, 2, 30))"/>
		
		public class <xsl:value-of select="$className"/>Command implements ICommand, IResponder
		{
			public function <xsl:value-of select="$className"/>Command()
			{	 
			}

			public function execute ( event : CairngormEvent) : void
			{
				var delegate : <xsl:value-of select="../@name"/>Delegate = new <xsl:value-of select="../@name"/>Delegate ( this );
				delegate.<xsl:value-of select="@name"/>( <xsl:for-each select='arg'> <xsl:if test="position() != 1">, </xsl:if> <xsl:value-of select="$className"/>Event(event).<xsl:value-of select="@name" /> </xsl:for-each>);
			}
		
			public function result( event : Object ) : void
			{
			<xsl:if test="@type != 'void'">
				var returnValue:<xsl:value-of select="@type" /> = event.result as <xsl:value-of select="@type" />;
			</xsl:if>
			}
		
			public function fault( event : Object ) : void
			{
				var faultEvent : FaultEvent = FaultEvent( event );
				Alert.show( faultEvent.fault.faultString);
			}
		}
	}
  </xsl:template>

  <xsl:template name="controller">
	package <xsl:value-of select="@namespace" />.control
	{
		import com.adobe.cairngorm.control.FrontController;	
		import <xsl:value-of select="@namespace" />.business.*;
		import <xsl:value-of select="@namespace" />.event.*;
		import <xsl:value-of select="@namespace" />.command.*;
        <xsl:call-template name="codegen.import.alltypes" />

		public class <xsl:value-of select="@name"/>Controller extends FrontController
		{
			public function <xsl:value-of select="@name"/>Controller()
			{
				initializeCommands();
			}		
		
			public function initializeCommands() : void
			{
				<xsl:for-each select='method'>
				<xsl:variable name="firstLetter" select="substring(@name, 1,1)"/>
				<xsl:variable name="className" select = "concat(translate($firstLetter, $lo, $up), substring(@name, 2, 30))"/>
		
				addCommand( <xsl:value-of select="$className"/>Event.GET_MESSAGE_<xsl:value-of select="@name"/>, <xsl:value-of select="$className"/>Command );
				</xsl:for-each>
			}
		}
	}
   </xsl:template>

 <xsl:template name="event"> 
	package <xsl:value-of select="../@namespace" />.event
	{
		import flash.events.Event;
		import com.adobe.cairngorm.control.CairngormEvent;
	<xsl:variable name="returnType" select="@type"/>
    <xsl:variable name="methodName" select="@name"/>
    <xsl:for-each select="//datatype">
        <xsl:if test="$returnType = @name or key('args', @name)/../@name = $methodName">
    import <xsl:value-of select="@typeNamespace"/>.vo.<xsl:value-of select="@name"/>;
        </xsl:if>
    </xsl:for-each>

		<xsl:variable name="firstLetter" select="substring(@name, 1,1)"/>
		<xsl:variable name="className" select = "concat(translate($firstLetter, $lo, $up), substring(@name, 2, 30))"/>

		public class <xsl:value-of select="$className"/>Event extends CairngormEvent
		{
			public static var GET_MESSAGE_<xsl:value-of select="@name"/>:String = "getMessage_<xsl:value-of select="@name"/>";

			public function <xsl:value-of select="$className"/>Event( type:String, <xsl:for-each select='arg'> <xsl:value-of select="@name" />:<xsl:value-of select="@type" />, </xsl:for-each> bubbles:Boolean=false, cancelable:Boolean=false)
			{
				super( type, bubbles, cancelable );
			<xsl:for-each select='arg'>
			_<xsl:value-of select="@name" /> = <xsl:value-of select="@name" />;
			</xsl:for-each>
			}
			<xsl:for-each select='arg'>
			private var	_<xsl:value-of select="@name" />:<xsl:value-of select="@type" />;
			</xsl:for-each>
			
			<xsl:for-each select='arg'>
			public function get <xsl:value-of select="@name" />():<xsl:value-of select="@type" />
			{
				return _<xsl:value-of select="@name" />;
			}
			</xsl:for-each>

			override public function clone() : Event
			{
				return new <xsl:value-of select="@name"/>Event(type, <xsl:for-each select='arg'> <xsl:value-of select="@name" />, </xsl:for-each> bubbles, cancelable);
			}	
		}
	}
  </xsl:template>
 

</xsl:stylesheet>
