<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0"
    xmlns:codegen="urn:weborb-cogegen-xslt-lib:xslt"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

  <xsl:import href="codegen.xslt"/>

  <xsl:key name="args" match="arg" use="@type"/>

  <xsl:template name="codegen.appmain">
    <file name="main.mxml"><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml" 
	layout="absolute" minWidth="955" minHeight="600"
	creationComplete="facade.startup(this)">
	
	<mx:Script>]]>
        <xsl:variable name="facadeName" select="concat(//service/@name, 'Facade')" />
      &lt;<![CDATA[![CDATA[
			import ]]><xsl:value-of select="concat(//service/@namespace, '.', //service/@name, 'Facade')"/><![CDATA[;
			private var facade:]]><xsl:value-of select="$facadeName"/><![CDATA[ = new ]]><xsl:value-of
                select="$facadeName"/><![CDATA[();
		]]]]>&gt;<![CDATA[
	</mx:Script>
	
	<!-- Rest of display hierarchy -->
</mx:Application>
    ]]>
    </file>
  </xsl:template>

  <xsl:template name="codegen.vo.folder" >
      <xsl:param name="version" select="3" />
      <xsl:choose>
          <xsl:when test="service">
              <folder name="model">
                  <folder name="vo">
                      <xsl:for-each select="service">
                          <file name="{@name}ResultVO.as">
                              <xsl:call-template name="codegen.model"/>
                          </file>
                      </xsl:for-each>
                      <xsl:for-each select="datatype">
                          <file name="{@name}.as">
                              <xsl:call-template name="codegen.description">
                                  <xsl:with-param name="file-name" select="concat(@name,'.as')"/>
                              </xsl:call-template>
                              <xsl:call-template name="vo">
                                  <xsl:with-param name="vo" select="concat('','')"/>
                              </xsl:call-template>
                          </file>
                      </xsl:for-each>
                  </folder>
                  <folder name="enum">
                      <xsl:for-each select="enum">
                          <xsl:call-template name="codegen.enum">
                              <xsl:with-param name="version" select="$version"/>
                          </xsl:call-template>
                      </xsl:for-each>
                      <file name="README.txt">
                          Place any applicable enumeration definitions in the model/enum folder
                      </file>
                  </folder>
                  <xsl:for-each select="service">
                      <file name="{@name}Proxy.as">
                          <xsl:call-template name="codegen.description">
                              <xsl:with-param name="file-name" select="concat(@name,'Proxy.as')"/>
                          </xsl:call-template>
                          <xsl:call-template name="proxy"/>
                      </file>
                  </xsl:for-each>
              </folder>
          </xsl:when>
          <xsl:when test="enum or datatype">
              <folder name="model">
                  <xsl:if test="datatype">
                      <folder name="vo">
                          <xsl:for-each select="datatype">
                              <file name="{@name}.as">
                                  <xsl:call-template name="codegen.description">
                                      <xsl:with-param name="file-name" select="concat(@name,'.as')"/>
                                  </xsl:call-template>
                                  <xsl:call-template name="vo">
                                      <xsl:with-param name="vo" select="concat('','')"/>
                                  </xsl:call-template>
                              </file>
                          </xsl:for-each>
                          <xsl:if test="enum">
                            <folder name="enum">
                              <xsl:for-each select="enum">
                                <xsl:call-template name="codegen.enum">
                                  <xsl:with-param name="version" select="$version"/>
                                </xsl:call-template>
                              </xsl:for-each>
                            </folder>
                          </xsl:if>
                      </folder>
                  </xsl:if>
              </folder>
          </xsl:when>
      </xsl:choose>

  </xsl:template>

  <xsl:template name="libs.folder.additional.content">
    <file name="readme.txt">
Project structure generated by WebORB includes all the source code and project files except the
library file for the PureMVC AS3 framework. You need to download and place the PureMVC_AS3_2_0_4.swc file
(or newer) in this folder.
    </file>
  </xsl:template>

  <!--<xsl:template name="codegen.project.custom">
    <folder name="libs">
	  <file name="readme.txt">
	  Project structure generated by WebORB includes all the source code and project files except the
	  library file for the PureMVC AS3 framework. You need to download and place the PureMVC_AS3_2_0_4.swc file
	  (or newer) in this folder.
	  </file>
	</folder>
  </xsl:template>-->

  <xsl:template name="codegen.service">
	  <xsl:param name="version" select="3" />
  	  <xsl:if test="count(//datatype) != 0">
        <file name="DataTypeInitializer.as">
          <xsl:call-template name="codegen.datatypelist">
            <xsl:with-param name="namespaceName" select="@namespace" />
            <xsl:with-param name="subnamespace" select="'.model.vo.'" />
          </xsl:call-template>
        </file>
      </xsl:if>
      <folder name="controller">
        <xsl:for-each select='method'>
            <file name="{@name}Command.as">
                <xsl:call-template name="codegen.description">
                    <xsl:with-param name="file-name" select="concat(@name,'Command.as')" />
                </xsl:call-template>
                <xsl:call-template name="controller" />
            </file>
        </xsl:for-each>
        <file name="StartupCommand.as">
            <xsl:call-template name="codegen.description">
                <xsl:with-param name="file-name" select="concat('','StartupCommand.as')" />
            </xsl:call-template>
        <xsl:call-template name="startup" />
        </file>
      </folder>

      <folder name="view">
        <folder name="components">
            <file name="README.txt">
            Place all UI components in the view/components folder. Each component should have a corresponding mediator.
            Mediators should be placed in the view folder.
            </file>
        </folder>
        <file name="{@name}Mediator.as">
            <xsl:call-template name="codegen.description">
                <xsl:with-param name="file-name" select="concat(@name,'Mediator.as')" />
            </xsl:call-template>
        <xsl:call-template name="mediator" />
        </file>
      </folder>
    <file name="{@name}Facade.as">
        <xsl:call-template name="codegen.description">
            <xsl:with-param name="file-name" select="concat(@name,'Facade.as')" />
        </xsl:call-template>
        <xsl:call-template name="facade" />
    </file>
  </xsl:template>

  <xsl:template name="vo">
  <xsl:param name="vo" />
    package <xsl:value-of select="@typeNamespace"/>.model.vo
    {
      <xsl:call-template name="codegen.import.fieldtypes"/>

      [RemoteClass(alias="<xsl:value-of select='@fullname'/>")]
      public class <xsl:value-of select="@name"/><xsl:value-of select="$vo"/>
      {
        <xsl:for-each select="field">
          public var <xsl:value-of select="@name"/>:<xsl:if test="@typeNamespace"><xsl:value-of select="@typeNamespace"/>.model.vo.<xsl:variable name="fulltype" select="@fulltype"/><xsl:if test="//enum[@fullname=$fulltype]">enum.</xsl:if></xsl:if><xsl:value-of select="@type"/>;
        </xsl:for-each>

          public function toString():String
          {
            return ""<xsl:if test="count(field) != 0"> + <xsl:for-each select="field">this.<xsl:value-of select="@name"/><xsl:if test="position()!=last()"> + ": " +
                   </xsl:if>
          </xsl:for-each></xsl:if>;
          }
      }
    }
  </xsl:template>

  <xsl:template name="proxy">
    package <xsl:value-of select="//service/@namespace"/>.model
    {
   	  import org.puremvc.as3.interfaces.IProxy;
      import org.puremvc.as3.patterns.proxy.Proxy;
      import org.puremvc.as3.patterns.observer.Notification;
      import <xsl:value-of select="@namespace" />.*;
      import mx.rpc.remoting.RemoteObject;
      import mx.rpc.events.ResultEvent;
      import mx.rpc.events.FaultEvent;
      import mx.rpc.AsyncToken;
      import mx.controls.Alert;
      <xsl:call-template name="import.all.vo"/>

      public class <xsl:value-of select="@name"/>Proxy extends Proxy implements IProxy
      {
        public static const NAME:String = '<xsl:value-of select="@name"/>Proxy';
        private var remoteObject:RemoteObject;

        public function <xsl:value-of select="@name"/>Proxy( )
        {
          super( NAME );
          remoteObject  = new RemoteObject("GenericDestination");
          remoteObject.source = "<xsl:value-of select='@fullname'/>";
          <xsl:for-each select="method">
          remoteObject.<xsl:value-of select="@name" />.addEventListener("result",<xsl:value-of select="@name" />Handler);
          </xsl:for-each>
          remoteObject.addEventListener("fault", onFault);
        }
        <xsl:for-each select='method'>
        public function <xsl:value-of select="@name"/>( <xsl:for-each select="arg">
        <xsl:value-of select="@name"/>:<xsl:value-of select="@type" /><xsl:if test="position() != last()">,</xsl:if></xsl:for-each>):void
        {
          remoteObject.<xsl:value-of select="@name"/>( <xsl:for-each select="arg"><xsl:value-of select="@name"/><xsl:if test="position() != last()">,</xsl:if></xsl:for-each>);
        }

        public virtual function <xsl:value-of select="@name"/>Handler(event:ResultEvent):void
        {
            sendNotification( <xsl:value-of select="../@name"/>Facade.<xsl:value-of select="@name"/>_finished, event.result );
        }
        </xsl:for-each>
        public function onFault (event:FaultEvent):void
        {
            sendNotification( <xsl:value-of select="@name"/>Facade.ERROR, event.fault.faultString );
        }
      }
    }
  </xsl:template>

  <xsl:template name="controller">
    package <xsl:value-of select="../@namespace" />.controller
    {
      import org.puremvc.as3.interfaces.ICommand;
      import org.puremvc.as3.interfaces.INotification;
      import org.puremvc.as3.patterns.command.SimpleCommand;
      import <xsl:value-of select="../@namespace" />.model.*;
      <xsl:variable name="methodName" select="@name"/>
      <xsl:for-each select="//datatype">
          <xsl:if test="key('args', @name)/../@name = $methodName">
      import <xsl:value-of select="@typeNamespace"/>.model.vo.<xsl:value-of select="@name"/>;
          </xsl:if>
      </xsl:for-each>

      public class <xsl:value-of select="@name"/>Command extends SimpleCommand implements ICommand
      {
        override public function execute( notification:INotification ) : void
        {
          var args:Array = notification.getBody() as Array;
          var proxy:<xsl:value-of select="../@name" />Proxy = facade.retrieveProxy( <xsl:value-of select="../@name" />Proxy.NAME ) as <xsl:value-of select="../@name" />Proxy;
          <xsl:for-each select="arg">
          var <xsl:value-of select="@name"/>:<xsl:value-of select="@type" />;
          </xsl:for-each>
          if( args != null )
          {
            args.reverse();
            <xsl:for-each select="arg">
            <xsl:value-of select="@name"/> = <xsl:value-of select="@type" />(args.pop());
            </xsl:for-each>
          }

          proxy.<xsl:value-of select="@name"/>(<xsl:for-each select="arg"><xsl:value-of select="@name"/><xsl:if test="position() != last()">,</xsl:if></xsl:for-each>);
        }
      }

    }
  </xsl:template>

  <xsl:template name="startup">
    package <xsl:value-of select="@namespace" />.controller
    {
      import org.puremvc.as3.interfaces.ICommand;
      import org.puremvc.as3.interfaces.INotification;
      import org.puremvc.as3.patterns.command.SimpleCommand;
      import <xsl:value-of select="@namespace" />.model.*;
      import <xsl:value-of select="@namespace" />.view.*;

      public class StartupCommand extends SimpleCommand implements ICommand
      {
        override public function execute( notification:INotification ) : void
        {
          facade.registerProxy( new <xsl:value-of select="@name"/>Proxy() );
          facade.registerMediator( new <xsl:value-of select="@name"/>Mediator() );
        }
      }

    }
  </xsl:template>

  <xsl:template name="mediator">
    package <xsl:value-of select="@namespace" />.view
    {
      import org.puremvc.as3.interfaces.IMediator;
      import org.puremvc.as3.interfaces.INotification;
      import org.puremvc.as3.patterns.mediator.Mediator;
      import mx.controls.Alert;
      import <xsl:value-of select="@namespace" />.*;
      import <xsl:value-of select="@namespace" />.model.*;
      <xsl:call-template name="import.all.vo" />


      public class <xsl:value-of select="@name"/>Mediator extends Mediator
      {
        private var proxy:<xsl:value-of select="@name"/>Proxy;
        public static const NAME:String = '<xsl:value-of select="@name"/>Mediator';

        public function <xsl:value-of select="@name"/>Mediator( viewComponent:Object = null )
        {
            super( NAME, viewComponent );

        }

		override public function onRegister():void
        {
         proxy = facade.retrieveProxy( <xsl:value-of select="@name"/>Proxy.NAME ) as <xsl:value-of select="@name"/>Proxy;
        }

        override public function listNotificationInterests():Array
        {
          return [
                    <xsl:value-of select="@name"/>Facade.ERROR,
                    <xsl:for-each select='method'>
                    <xsl:value-of select="../@name"/>Facade.<xsl:value-of select="@name"/>_finished<xsl:if test="position() != last()">,
                    </xsl:if></xsl:for-each>
          ];
        }

        override public function handleNotification( note:INotification ):void
        {
          switch ( note.getName() )
          {
            case <xsl:value-of select="@name"/>Facade.ERROR:
              Alert.show(note.getBody() as String, "Error");
              break;
            <xsl:for-each select='method'>
            case <xsl:value-of select="../@name"/>Facade.<xsl:value-of select="@name"/>_finished:
            <xsl:if test="@type != 'void'">
              <xsl:value-of select="../@name"/>Facade.getInstance().<xsl:value-of select="../@name"/>Result.<xsl:value-of select="@name"/>Result = note.getBody() as <xsl:value-of select="@type" />;
            </xsl:if>
              break;
            </xsl:for-each>
          }
        }
      }

    }
  </xsl:template>

  <xsl:template name="facade">
package <xsl:value-of select="@namespace" />
{
  import org.puremvc.as3.interfaces.IFacade;
  import org.puremvc.as3.patterns.facade.Facade;
  import <xsl:value-of select="@namespace" />.controller.*;
  import <xsl:value-of select="@namespace" />.*;
  import <xsl:value-of select="concat(@namespace, '.model.vo.', @name, 'ResultVO')" />;

  public class <xsl:value-of select="@name"/>Facade extends Facade implements IFacade
  {
      public static const STARTUP:String = "startup";
      public static const ERROR:String = "error";
      <xsl:for-each select='method'>
      public static const <xsl:value-of select="@name"/>:String = "<xsl:value-of select="@name"/>";
      public static const <xsl:value-of select="@name"/>_finished:String = "<xsl:value-of select="@name"/> finished";
      </xsl:for-each>

      [Bindable]
      public var <xsl:value-of select="@name"/>Result:<xsl:value-of select="@name"/>ResultVO;

      public function <xsl:value-of select="@name"/>Facade()
      {
        <xsl:value-of select="@name"/>Result = new <xsl:value-of select="@name"/>ResultVO();
      }

      public static function getInstance() : <xsl:value-of select="@name"/>Facade
      {
        if ( instance == null )
          instance = new <xsl:value-of select="@name"/>Facade( );
        
        return instance as <xsl:value-of select="@name"/>Facade;
      }
      
      override protected function initializeController( ) : void
      {
        super.initializeController();

        registerCommand( STARTUP, <xsl:value-of select="@namespace" />.controller.StartupCommand );
        <xsl:for-each select='method'>
        registerCommand( <xsl:value-of select="@name"/>, <xsl:value-of select="../@namespace" />.controller.<xsl:value-of select="@name"/>Command );
        </xsl:for-each>
      }
      
      // Startup the PureMVC apparatus, passing in a reference to the application
      public function startup(app:main):void
      {
        sendNotification(STARTUP, app);
      }
  }
}
  </xsl:template>

    <xsl:template name="codegen.model">
    <xsl:call-template name="codegen.description">
      <xsl:with-param name="file-name" select="concat(@name,'ResultVO.as')" />
    </xsl:call-template>

    package <xsl:value-of select="@namespace" />.model.vo
    {<xsl:call-template name="codegen.import.alltypes" ><xsl:with-param name="subnamespace" select="'model.vo'" /></xsl:call-template>
      [Bindable]
      public class <xsl:value-of select="@name"/>ResultVO
      {<xsl:for-each select="method"><xsl:if test="@type != 'void'">
        public var <xsl:value-of select="@name" />Result:<xsl:variable name="argtype" select="@type"/><xsl:if test="//datatype[@name=$argtype]"><xsl:value-of select="substring-before(@javatype, @type)"/>model.vo.</xsl:if><xsl:value-of select='@type'/>;</xsl:if></xsl:for-each>
      }
    }
  </xsl:template>

    <xsl:template name="import.all.vo">
        <xsl:for-each select="//namespace">
            <xsl:if test="datatype">
      import <xsl:value-of select="@fullname" />.model.vo.*;</xsl:if>
        </xsl:for-each>
    </xsl:template>

</xsl:stylesheet>
